#ifndef Simulate_HH
#define Simulate_HH

#include "Geom.hh"
#include "ElectronData.hh"
#include "PhotonData.hh"

#include "Random.hh"
#include "Track.hh"
#include "TrackStack.hh"

#include <cstdio>

//#define USE_REAL_MATERIAL

//
// Roate the direction [u,v,w] given in the scattering frame to the lab frame.
// Details: scattering is described relative to the [0,0,1] direction (i.e. scattering
// frame). Therefore, after the new direction is computed relative to this [0,0,1]
// original direction, the real original direction [u1,u2,u3] in the lab frame
// needs to be accounted and the final new direction, i.e. in the lab frame is
// computed.
void RotateToLabFrame(double &u, double &v, double &w, double u1, double u2, double u3) {
  double up = u1*u1 + u2*u2;
  if (up>0.) {
    up = std::sqrt(up);
    double px = u;
    double py = v;
    double pz = w;
    u = (u1*u3*px - u2*py)/up + u1*pz;
    v = (u2*u3*px + u1*py)/up + u2*pz;
    w =    -up*px +             u3*pz;
  } else if (u3<0.) {       // phi=0  teta=pi
    u = -u;
    w = -w;
  }
}
void RotateToLabFrame(double* dir, double* refdir) {
  RotateToLabFrame(dir[0], dir[1], dir[2], refdir[0], refdir[1], refdir[2]);
}



// implemented below:
// This keep tracking an e- till:
// 1. a discrete brem interaction take place
// 2. a discrete ioni interaction take place
// 3. MSC hinge or end of MSC step take place
// 4. the electron energy drops below zero so stops
int KeepTrackingElectron(ElectronData& elData, Geom& geom, double& numElMFP, double& numMollerMFP, double invMollerMFP, double& numBremMFP, Track& track);
//
// This keep tracking a photon till:
// 1. pair-production take place
// 2. Compton sattering take place
// 3. Photoelectric absoprtion take place
// Unlike in case of electrons, this function also performs the interactions
// themself since the photon interactions are very simple in DPM
void KeepTrackingPhoton(PhotonData& phData, Geom& geom, Track& track);
//
// Auxiliary funtion for sampling energy transfer in Moller ineraction
double SampleETransferInMoller(double ekin, double ecut, ElectronData& elData, double& cost);
//
double SampleETransferInKleinNishina(double egamma, PhotonData& phData, double& cost);
//
void PerformAnnihilation(Track& track);


void  Simulate(int nprimary, double e0, double lbox, ElectronData& elData, PhotonData& phData) {
  const double kPI            = 3.1415926535897932;
  const double kEMC2          = 0.510991;
  const double kHalfSqrt2EMC2 = kEMC2 * 0.7071067812;
  //
  // Create a c++11 RNG for getting uniformly random values in [0,1) (seed: 1234)
  // NOTE: I will use my simple Random util class for this.
  //
  // create the simple geometry
  Geom geom(lbox);
  //
  // fix the reference material index to be 0 !! not very nice bot ok for now
//  int refMatIndx = 0; // WATER i.e. density = 1.0 g/cm3 so not included

  // rz_0 such that the particle hits the first voxel/box with iz index of 0 --> |0|1|...
  // NOTE: its in box z-index 0
  const double theRZ0 = -0.5*lbox;
  //
  // simulate `nprimary` histories
  const int kFraction = nprimary/10;
  std::cout << "\n === Start simulation of N = " << nprimary << " events === \n" << std::endl;
  for (int iPrimary=0; iPrimary<nprimary; ++iPrimary) {
    if (iPrimary%kFraction==0) { std::cout << " == Starting Primary = " << iPrimary << std::endl; }
    // insert a track into the global track-stack with the properties of the primary
    // (note the Track is Reset() inside;)
    Track& aPrimaryTrack = TrackStack::Instance().Insert();
    // set the primary kinetic energy (position, direcion, type etc is fine)
    aPrimaryTrack.fEkin         = e0;
    aPrimaryTrack.fType         = -1;
    aPrimaryTrack.fDirection[0] = 0.0;
    aPrimaryTrack.fDirection[1] = 0.0;
    aPrimaryTrack.fDirection[2] = 1.0;

    aPrimaryTrack.fPosition[0] = 0.0;
    aPrimaryTrack.fPosition[1] = 0.0;
    aPrimaryTrack.fPosition[2] = theRZ0;

    //
    // While the secondary stack becomes empty: pop the next seconday and track
    // till its ekin becomes zero.
    // NOTE: secondary stack might be populated while tracking
    Track track; // this is the current Track that is under tracking
    while (-1 < TrackStack::Instance().PopIntoThisTrack(track)) {
          // compute the distance to the boundary
          // (This also sets the box indices so the material index can be obtained)
          // init the step length to this distance to boundary
//          double step =
          geom.DistanceToBoundary(track.fPosition, track.fDirection, track.fBoxIndx);
//          std::cout << " ===== " << std::endl;
//          std::cout << " i[] = "<<track.fBoxIndx[0]   << " " << track.fBoxIndx[1]   << " " <<track.fBoxIndx[2] << "\n"
//                    << " r[] = "<<track.fPosition[0]  << " " << track.fPosition[1]  << " " <<track.fPosition[2]<< "\n"
//                    << " s = " << step<< " E0 = " << track.fEkin << " type = " << track.fType<< std::endl;
//           if (track.fBoxIndx[2]< 0 ) {
//             std::cout << " *** " << track.fType << " E = " << track.fEkin << " trackL = "<<track.fTrackLength << " imat = " << track.fMatIndx<<std::endl;
//           }
          // get the current material index: i.e. the base material of the voxel
          int theVoxelMatIndx = geom.GetMaterialIndex(track.fBoxIndx);
          track.fMatIndx      = theVoxelMatIndx;
          // Track the photons separately:
          if (track.fType == 0) {
//            std::cout << " --- Photon " << std::endl;
            KeepTrackingPhoton(phData, geom, track);
            continue;
          }
          //
          // Track e-/e+ ortherwise:
          //
          // WE ASSUME HERE NOW THAT EACH VOXEL IS A CLEAR MATERIAL SO WE WILL
          // USE theVoxelMaterialDensity = theVoxelBaseMaterialDensity;
          // NOTE: density must be in g/cm3 units !!!!
          double theVoxelMatDensity = theVoxelMatIndx > -1 ? elData.fDataPerMaterial[theVoxelMatIndx]->fMaterialDensity : 1.0E-40;
          // This reference material might be used for Moller and Elastic realted scalings
          // NOTE: if we are in the vacuum then the theVoxelMatIndx = -1
          int    theRefMatIndx      = std::min(theVoxelMatIndx, 0);
          //
          // this will be used to alter between an msc hinge and remaining sub-steps
          bool   isMSCHinge = true;
          // this will be used to keep track of the pre-step point energy that we need
          // when we reach the msc hinge point (init. is not important cause will be set below)
          double theEkin0        = track.fEkin;
          //
          //
          // Compute the initial number of mfp left till the different interactions (s/mfp):
          //
          // 1. elastic interaction with msc: s/tr1mfp and sample the hinge position as well
//          double numElMFP   = elData.GetMaxAllowedScatLengthPerDensity(track.fEkin, theRefMatIndx);//*theVoxelMatDensity;
double numElMFP   = elData.GetMaxAllowedScatLength(track.fEkin, theRefMatIndx);

          double numElMFP0  = Random::UniformRand()*numElMFP; // travell this #mfp after the hinge
          numElMFP         -= numElMFP0;         // #mfp till the hinge
          // 2. Moller:
          // NOTE: as in DPM, the mfp for Moller will be assumed to have no energy dependence!!!
          //       So the update of the number of mfp left will contain only the material
          //       dependence related scaling (that's again approximate but DPM does this).
          //       This material dependent update(scaling) relies on the \lam ~ [A/(Z\rho)]
          //       dependence: \lam' = \lam_ref(E') [Z\rho/A]_ref [A/(Z\rho)]_actual (such
          //       that in case of Moller (in DPM) even E'=E_0 in each step as dicussed above).
          double numMollerMFP = -std::log(Random::UniformRand());
//          double invMollerMFP = elData.GetMollerIMFPPerDensity(track.fEkin, theVoxelMatIndx)*theVoxelMatDensity;
double invMollerMFP = elData.GetMollerIMFPPerDensity(track.fEkin, theRefMatIndx); // [1/mm /(g/cm3)]
          // 3. bremsstrahlung:
          // NOTE: in the DPM papaer there is a material related scaling but I do not see
          //       some part of that in the DPM code:
          // \lam' = \lam_ref(E') [Z^2\rho/A]_ref [A/(Z^2\rho)]_actual  that is due to the
          // \lam ~ [A/(Z^2\rho)]. But eventually, when the number of mfp left should be
          // updated and \Delta s/\lam' is computed then 1/\lam' = 1/\lam_ref(E') \rho_actual
          // in the DPM code. So
          //  1. dividion with \rho_ref is missing becasue \lam_ref is actually includes
          //     this since \lam_ref is actually \lam_ref \rho_ref (where \rho_ref in [g/cm3]
          //     i.e. 1 g/cm3 for water). NOTE: all \rho needs to be used in [g/cm3]!!!
          //  2. but the remaining factor [A/Z^2]_ref [Z^2/A]_actual is missing in DPM!!! ???
          // We will do the same in order to be consistent with DPM.
          double numBremMFP = -std::log(Random::UniformRand());

          //
          // Start tracking while the primary is stopped i.e. its energy becomes zero
          while (track.fEkin > 0.0) {
            //
            // Now we can keep tracking this e- (even trhough boxes with different materials),
            // by decreasing these 3 above initial number of mfp left at each step by the
            // correspnding n' = n - dS/mfp' as long as:
            // a.  any of these above 3 number of mfp goes to zero ==> the correspnding
            //     discrete Brem.(1), Moller(2) interaction happens or (3) either the MSC
            //     hinge or end point is reached
            // b.  (4) the e- energy drops below the e- tracking cut which is equal to the
            //     secondary e- production threshold (end of this history)
            // c.  the e- leaves the geometry (not in our case: our geometry is infinite now)
            int whatHappend = KeepTrackingElectron(elData, geom, numElMFP, numMollerMFP, invMollerMFP, numBremMFP, track);
            //
            theVoxelMatIndx    = track.fMatIndx;
            theVoxelMatDensity = theVoxelMatIndx > -1 ? elData.fDataPerMaterial[theVoxelMatIndx]->fMaterialDensity : 1.0E-40;
            // either vacuum or or the reference material
            theRefMatIndx      = std::min(theVoxelMatIndx, 0);
            switch (whatHappend) {
//              std::cout << " theVoxelMatDensity = " << theVoxelMatDensity << " whatHappend = " << whatHappend << std::endl;
              // (1) discrete bremsstrahlung interaction should be sampled:
              //     - sample energy transfer to the photon (if any)
              // SO WE ONLY RESAMPLE THE #MFP LEFT TILL THE NEXT DISCRETE BREM. INTERACTION
              case 1 : {
                         const double gcut = elData.fGammaCut;
                         double theGammaEnergy = 0.0;

                         if ( track.fEkin > gcut ) {
                            theGammaEnergy = elData.fSBTables->SampleEnergyTransfer(theVoxelMatIndx, track.fEkin, gcut,
                                                                                    Random::UniformRand(),
                                                                                    Random::UniformRand(),
                                                                                    Random::UniformRand());
                           // insert the secondary gamma track into the stack
                           Track& aTrack        = TrackStack::Instance().Insert();
                           aTrack.fType         = 0;
                           aTrack.fEkin         = theGammaEnergy;
                           aTrack.fMatIndx      = track.fMatIndx;
                           aTrack.fPosition[0]  = track.fPosition[0];
                           aTrack.fPosition[1]  = track.fPosition[1];
                           aTrack.fPosition[2]  = track.fPosition[2];
                           aTrack.fBoxIndx[0]   = track.fBoxIndx[0];
                           aTrack.fBoxIndx[1]   = track.fBoxIndx[1];
                           aTrack.fBoxIndx[2]   = track.fBoxIndx[2];
                           //
                           // compute emission direction (rough approximation in DPM by the mean)
                           // and no deflection of the primary e-
                           const double dum0    = kHalfSqrt2EMC2/(track.fEkin+kEMC2);
                           const double cost    = std::max(-1.0, std::min(1.0, 1.0-dum0*dum0));
                           const double sint    = std::sqrt((1.0+cost)*(1.0-cost));
                           const double phi     = 2.0*kPI*Random::UniformRand();
                           aTrack.fDirection[0] = sint*std::cos(phi);
                           aTrack.fDirection[1] = sint*std::sin(phi);
                           aTrack.fDirection[2] = cost;
                           RotateToLabFrame(aTrack.fDirection, track.fDirection);

                           // decrease primary energy:
                           // NOTE: it seems that there primary is not deflected
                           //       according to the momentum conservation in DMP!
                           track.fEkin = track.fEkin-theGammaEnergy;
                         }
                         // check if the post-interaction electron energy droped
                         // below the tracking cut and stop tracking if yes
                         if (track.fEkin < elData.fElectronCut) {
                           // deposit the whole energy and stop tracking
                           geom.Score(track.fEkin, track.fBoxIndx[2]);
                           //geom.Score(track.fEkin, track.fPosition[2]);
                           track.fEkin  = 0.0;
                           if (track.fType == +1) {
                             PerformAnnihilation(track);
                           }
                           break;
                         }

                         // re-sample the #mfp to travel till the next brem event
                         numBremMFP = -std::log(Random::UniformRand());
                         break;
                       }
              // (2) discrete Moller interaction is sampled: use rejection now as refernce
              // NOTE: no energy dependence is considered in case of Moller in DPM so
              //       the numMollerMFP is evaluated only at this point and assumed to be
              //       constant aloneg the `KeepTracking`
              //       furthermore, the kinetic energies of both the post interaction priary
              //       and seconday electrons are guarantied to be above the secondary electron
              //       production threshold so no need to check if their energy is below after
              //       the interaction
              //       furthermore, note that Moller interaction is independent from Z
              case 2 : {
                          double secCost = 1.0;
                          double secEkin = SampleETransferInMoller(track.fEkin, elData.fElectronCut, elData, secCost);
                         // if interaction was possible. i.e. both seconday and post-intecation primary ekin > ecut
                         if (secEkin>0.0) {
                           // insert the secondary e- track into the stack
                           Track& aTrack        = TrackStack::Instance().Insert();
                           aTrack.fType         = -1;
                           aTrack.fEkin         = secEkin;
                           aTrack.fMatIndx      = track.fMatIndx;
                           aTrack.fPosition[0]  = track.fPosition[0];
                           aTrack.fPosition[1]  = track.fPosition[1];
                           aTrack.fPosition[2]  = track.fPosition[2];
                           aTrack.fBoxIndx[0]   = track.fBoxIndx[0];
                           aTrack.fBoxIndx[1]   = track.fBoxIndx[1];
                           aTrack.fBoxIndx[2]   = track.fBoxIndx[2];
                           const double sint    = std::sqrt((1.0+secCost)*(1.0-secCost));
                           const double phi     = 2.0*kPI*Random::UniformRand();
                           aTrack.fDirection[0] = sint*std::cos(phi);
                           aTrack.fDirection[1] = sint*std::sin(phi);
                           aTrack.fDirection[2] = secCost;
                           RotateToLabFrame(aTrack.fDirection, track.fDirection);
                           // decrease primary energy:
                           // NOTE: it seems that there primary is not deflected
                           //       according to the momentum conservation in DMP!
                           track.fEkin -= secEkin;
                         }
                         // resample #mfp left since the energy has changed
                         numMollerMFP = -std::log(Random::UniformRand());
invMollerMFP = elData.GetMollerIMFPPerDensity(track.fEkin, theRefMatIndx);
                         break;
                       }
              // (3) msc interaction happend: either hinge or just refuel
              case 3 : {
                       if (isMSCHinge) {
                          // Sample angular deflection from GS distr. and apply it
                          // -----------------------------------------------------

                          const double dum0 = elData.SampleFromGSDtr(theEkin0, theRefMatIndx, Random::UniformRand(), Random::UniformRand());
                          const double cost = std::max(-1.0, std::min(1.0, dum0));
                          const double sint = std::sqrt((1.0-cost)*(1.0+cost));
                          // smaple \phi: uniform in [0,2Pi] <== spherical symmetry of the scattering potential
                          const double phi  = 2.0*kPI*Random::UniformRand();
                          // compute new direction (relative to 0,0,1 i.e. in the scattering frame)
                          double u1 = sint*std::cos(phi);
                          double u2 = sint*std::sin(phi);
                          double u3 = cost;
                          // rotate new direction from the scattering to the lab frame
                          RotateToLabFrame(u1, u2, u3, track.fDirection[0], track.fDirection[1], track.fDirection[2]);
                          // update track direction
                          track.fDirection[0] = u1;
                          track.fDirection[1] = u2;
                          track.fDirection[2] = u3;

                          // -----------------------------------------------------
                          // set the #mfp left to the remaining, i.e. after hinge part
                          numElMFP   = numElMFP0;
                          // the end point is the next msc stop and not the hinge
                          isMSCHinge = false;
                        }  else {
                          // end point so resample #mfp left and the hinge point
                          theEkin0   = track.fEkin;
//                          numElMFP   = elData.GetMaxAllowedScatLengthPerDensity(theEkin0, theRefMatIndx)*theVoxelMatDensity;
numElMFP   = elData.GetMaxAllowedScatLength(theEkin0, theRefMatIndx);

                          numElMFP0  = Random::UniformRand()*numElMFP; // travell this #mfp after the hinge
                          numElMFP  -= numElMFP0;         // #mfp till the hinge
                          // hinge will be the next msc stop
                          isMSCHinge = true;
                        }
                        break;
                      }
              // (4) the kinetic energy dropped below the tracking cut so the particle is stopped
              case 4 :  // nothng to do now: track.fEkin should be  = 0 et this point so the
                        // "traking" while loop should be terminated
                        break;
            }
          } // end of tracking while loop
    }// end of this history (i.e. end of tracking the even the last track from this history)
  } // end of tracking all the primaries (i.e. end of tracking the last primary)
  std::cout << "\n === End simulation of N = " << nprimary << " events === \n" << std::endl;

  //
  // White the histogram: depth dose [MeV /cm] as a function of depth [cm]
  //
  FILE *f = fopen("hist.sim","w");
  fprintf(f, "# === Energy deposite as a function of the depth === \n");
  fprintf(f, "# === Index    Depth [cm]    Edep [MeV/cm] / matDensity [g/cm3] === \n");
//  fprintf(f, "# === Index    Depth [cm]    Edep [MeV/cm] === \n");
  const double toCm = 0.1;
  std::vector<double>& theHist    = geom.GetEdepHist();
  std::vector<double>& theStpHist = geom.GetStepHist();
  int numHist = theHist.size();
  double norm = 1./(nprimary*lbox*toCm);
  double sum = 0.0;
  int idumy[] = {0,0,0};
  for (int i=0; i<numHist; ++i) {
    idumy[2] = i;
    int matIndex = geom.GetMaterialIndex(idumy);
    double matDensity = elData.GetMaterialDensity(matIndex); // in g/cm3
    fprintf(f, " %.10d    %13.4e    %13.4e    %13.4e\n", i, (i+0.5)*lbox*toCm, theHist[i]*norm/matDensity, theStpHist[i]/nprimary);
//    fprintf(f, " %.10d    %13.4e    %13.4e\n", i, (i+0.5)*lbox*toCm, theHist[i]*norm);
    sum += theHist[i];
  }
  fclose(f);
  std::cout << " === Energy deposite histogram is written to the `hist.sim` file." << std::endl;
  std::cout << " === Total energy deposit in target: " << sum/nprimary << " [MeV/event] \n"<< std::endl;

//  std::cout << " Totalenergy depo = " << sum << std::endl;
}

int KeepTrackingElectron(ElectronData& elData, Geom& geom, double& numElMFP, double& numMollerMFP, double invMollerMFP, double& numBremMFP, Track& track) {
  // used only for scoring in the central-z voxels
//  const double kHalfBoxSize = geom.GetLHalfBox();
  // case 1,2, 3 and 4

  int whatHappend = 0;
  // compute the distance to boundary: this will be a maximal step length
  double stepGeom = geom.DistanceToBoundary(track.fPosition, track.fDirection, track.fBoxIndx);
  if (stepGeom<0.0) {
    // left the geometry
    track.fEkin = 0.0;
    return 4;
  }
/*
  double fuelmo = numMollerMFP;
  double fuelbr = numBremMFP;
  double fuelel = numElMFP;
*/

//  std::cout << "   i[] = "<<track.fBoxIndx[0]   << " " << track.fBoxIndx[1]   << " " <<track.fBoxIndx[2] << "\n"
//            << "   r[] = "<<track.fPosition[0]  << " " << track.fPosition[1]  << " " <<track.fPosition[2]<< "\n"
//            << "   s = " << stepGeom<<std::endl;

  // refernce material index (NOTE: changing matDensity below to 1.0 and refMatIndx = matIndx
  // would lead to the computation of all quantities to the crrect material)
  //  int refMatIndx  = 0;
  // The Moller mfp energy dependence is not considered in DPM so we do the same:
  // we will keep using the Moller mfp evaluated at the initial energy for the reference
  // material. Only the material scaling will be applied below:
  // \lam' = \lam_ref(E') [Z\rho/A]_ref [A/(Z\rho)]_actual (for 1/\lam' to compute delta #mfp)
//  double invMollerMFP = elData.GetMollerIMFP(track.fEkin, refMatIndx);
  while (whatHappend==0) {
    // init the current step lenght to that of the distance to boundary: we might
    // or might not go that far (depending on what the 3 physics tells) but for
    // sure that is the maximum step length becasue 'boundary crossing interaction'
    // happens after travelling that far. So set what happen to that (i.e. = 0.)
    double stepLength = stepGeom;
    whatHappend = 0;
    // get the current material index (when computing distance to boundary fBoxIndx
    // is updated if needed, i.e. if we crossed a boundary)
    int theVoxelMatIndx = geom.GetMaterialIndex(track.fBoxIndx);
    track.fMatIndx      = theVoxelMatIndx;
    // This reference material might be used for Moller and Elastic realted scalings
    int theRefMatIndx   = 0;//theVoxelMatIndx;//0; // Water is always the very first material !!!
    // the material scaling factor for the Moller inverse-mf: [A/(Z\rho/)]_ref [(Z\rho)/A]_actual
    // or more exactly its [A/Z)]_ref [(Z)/A]_actual part
    double scalMolMFP = 1.0;
    if (theVoxelMatIndx > -1) {
      scalMolMFP    = elData.fDataPerMaterial[theVoxelMatIndx]->fAtomicNumber/elData.fDataPerMaterial[theVoxelMatIndx]->fAtomicWeight;
      scalMolMFP   *= elData.fDataPerMaterial[theRefMatIndx]->fAtomicWeight/elData.fDataPerMaterial[theRefMatIndx]->fAtomicNumber;
    }
    // WE ASSUME HERE NOW THAT EACH VOXEL IS A CLEAR MATERIAL SO WE WILL
    // USE theVoxelMaterialDensity = theVoxelBaseMaterialDensity;
    // NOTE: density must be in g/cm3 units !!!!
    double theVoxelMatDensity = theVoxelMatIndx > -1 ? elData.fDataPerMaterial[theVoxelMatIndx]->fMaterialDensity : 1.0E-40;
    //
    // Here we compute the decrese of the #mfp for the 3 interaction with the current,
    // maximum step length (i.e. the distance to boundary): #mfp' = #mfp - ds/mfp'
    // (where ' indicates values at the end point)
    //
    // compute the mid-point energy along this step by assuming:
    // - constant dEdx along the step, i.e. dEdx=dEdx(E_0) and dE = s dEdx --> E_mid = E_0 - 0.5 s dEdx
    // - the step equal to the current one, i.e. `stepLength` (dist. to boundary)
    // the restricted stopping power for this material: for the referecne material and scalled with the current density
    double theDEDX    = elData.GetDEDXPerDensity(track.fEkin, theVoxelMatIndx)*theVoxelMatDensity;
    // make sure that do not go below the minim e- energy
    double midStepE   = std::max(track.fEkin-0.5*stepLength*theDEDX, elData.fElectronCut );
    //midStepE = track.fEkin;
    // elastic: #mfp' = #mfp - ds/mfp' with mfp = tr1mfp so the change in #mfp is ds/mfp' and
    //          1/mfp' is computed here
    // NOTE: the tr1mfp (first transport mfp) is evaluated for th erefernce material and scalled
    double delNumElMFP     = elData.GetInvTotal1rstTransportMFPPerDensity(midStepE, theVoxelMatIndx)*theVoxelMatDensity;
    // moller: see above the details where `invMollerMFP` is set (IN COMMENT NOW SINCE invMollerMFP is input arg.)
    double delNumMollerMFP = invMollerMFP*scalMolMFP*theVoxelMatDensity;
    // brem: #mfp' = #mfp - ds/mfp' with mfp = brem_mfp so the change in #mfp is ds/mfp' and
    //       1/mfp' is computed here
    // NOTE: the brem_mfp is evaluated for the refernce material and scalled
    double delNumBremMFP   = elData.GetBremIMFPPerDensity(midStepE, theVoxelMatIndx)*theVoxelMatDensity;
    //
    //
    // Now we will see how far actually we go by trying to decrese each of the 3 #mfp
    // by the changes in the number of mfp computed above as `delNum` :
    // - if we could manage to decrese all the 3 #mfp such that they are > 0
    //   then actually we reached the boundary: we cross and perform an other step.
    // - if any of the 3 #mfp goes down to zero, then the lowest (i.e. shortest
    //   path to) will be considered to happen: the given inetraction need to be
    //   invoked
    // In all cases, the energy loss along the given step needs to be computed!
    //
    // In DMP, the #mfp are tried to decresed with the current step length (that
    // is alwasy the current shortest) as #mfp: n' = n - ds/mfp' then corrected
    // back if goes below zero, etc...
    // We compute the step length ds = n mfp' i.e. that would bring numBremMFP
    // down to 0 (since n'=n-ds/mfp'). If this steo is the shortest then we take
    // this as current steo length and we determine the overal shortest and the
    // corresponding interaction will happen.


/*
    double burnel = delNumElMFP;
    double burnmo = invMollerMFP*scalMolMFP*theVoxelMatDensity;
    double burnbr = delNumBremMFP;

    //   *** Burn Moller fuel:
    fuelmo = fuelmo-stepLength*burnmo;
    if (fuelmo<=0.0) {
      double sback = -fuelmo/burnmo;
      stepLength = stepLength-sback;
      fuelmo = 0.0;
      whatHappend = 2;
    }

    //   *** Burn bremss fuel:
    fuelbr = fuelbr-stepLength*burnbr;
    if (fuelbr<=0.0) {
      double sback = -fuelbr/burnbr;
      stepLength = stepLength-sback;
      fuelmo = fuelmo+sback*burnmo;
      fuelbr = 0.0;
      whatHappend = 1;
    }

    //   *** Burn elastic fuel:
    double infuel = fuelel;
    fuelel = fuelel-stepLength*burnel;
    if (fuelel<=0.0) {
//c         *** Refine calculation of scattering 1st MFP:
      double news = infuel/(elData.GetInvTotal1rstTransportMFPPerDensity(track.fEkin, theVoxelMatIndx)*theVoxelMatDensity);
      double newe = std::max(track.fEkin-0.5*theDEDX*news, elData.fElectronCut);
      news = infuel/(elData.GetInvTotal1rstTransportMFPPerDensity(newe, theVoxelMatIndx)*theVoxelMatDensity);
      if (news>stepLength) news = stepLength;
      double sback = stepLength-news;
      stepLength = news;
      fuelmo = fuelmo+sback*burnmo;
      fuelbr = fuelbr+sback*burnbr;
      fuelel = 0.0;
      whatHappend = 3;
    }
*/



    double stepBrem    = numBremMFP/delNumBremMFP;
    if (stepBrem < stepLength) {
      // discrete bremsstrahlung (might) happen before reaching the boundary:
      stepLength  = stepBrem;
      whatHappend = 1;
    }
    double stepMoller  = numMollerMFP/delNumMollerMFP;
    if (stepMoller < stepLength) {
      // discrete Moller (might) happen even before bremsstrahlung:
      stepLength  = stepMoller;
      whatHappend = 2;
    }
    double stepElastic = numElMFP/delNumElMFP;
    if (stepElastic < stepLength) {
      // elastic interaction happens:
      // - either the hinge: sample and apply deflection and update numElMFP to the
      //                     remaining part
      // - end of 2nd step : nothing to do just resample the #mfp left since all
      //                     has been eaten up by the step lenght travelled so far
      // Before anything, refine the comutation of the mfp (i.e. the first transprt
      // mean free path in acse of elastic) regarding its energy dependence.
      // NOTE: that the 1/mfp values were computed at the mid-point energy (brem
      //       and elatsic since Moller is assumed to be constant), assuming that
      //       the geometry step will be taken and the dEdx is constant along this
      //       step (i.e. no energy dependence).
      //       Here we know that actually not the geometry step, but the stepElastic
      //       is taken since that is the shortest. So we recompute the mid-step-point
      //       energy according to the step lenght of stepElastic and re-evaluate
      //       the 1./mfp i.e. 1/tr1mfp at this energy value
      stepElastic = numElMFP/(elData.GetInvTotal1rstTransportMFPPerDensity(track.fEkin, theVoxelMatIndx)*theVoxelMatDensity);
      midStepE    = std::max( track.fEkin-0.5*stepElastic*theDEDX, elData.fElectronCut );
      delNumElMFP = elData.GetInvTotal1rstTransportMFPPerDensity(midStepE, theVoxelMatIndx)*theVoxelMatDensity;
      // don't let longer than the original in order to make sure that it is still the
      // minimum of all step lenghts
      stepElastic = std::min(stepLength, numElMFP/delNumElMFP);
      stepLength  = stepElastic;
      whatHappend = 3;
    }
    //
    // At this point, we know the step lenght so we can decrease all #mfp by
    // substracting the delta #mfp = ds/#mfp that correspond to this final stepLength
    numBremMFP   = (whatHappend == 1) ? 0 : numBremMFP   - stepLength*delNumBremMFP;
    numMollerMFP = (whatHappend == 2) ? 0 : numMollerMFP - stepLength*delNumMollerMFP;
    numElMFP     = (whatHappend == 3) ? 0 : numElMFP     - stepLength*delNumElMFP;


    //
    // Compte the (sub-treshold, i.e. along step) energy loss:
    // - first the mid-step energy using the final value of the step lenght and the
    //   pre-step point dEdx (assumed to be constant along the step).
    midStepE     = std::max( track.fEkin-0.5*stepLength*theDEDX, elData.fElectronCut );
    // - then the dEdx at this energy
    theDEDX      = elData.GetDEDXPerDensity(midStepE, theVoxelMatIndx)*theVoxelMatDensity;
    // - then the energy loss along the step using the mid-step dEdx (as constant)
    //   and the final energy
    double deltE = stepLength*theDEDX;
    double eFinal= track.fEkin-deltE;
    // check if energy dropped below tracking cut, i.e. below seconday e- production threshold
    // NOTE: HERE THERE IS A SUB-THRESHOLD TRACKING CONDITION IN DPM BUT WE WILL NEED TO SEE THAT !!!
    // ALSO: IF THE SELECTED STEP LENGHT BRINGS THE EKIN BELOW THRESHOLD WE DON'T TRY TO FIND THE
    //       STEP LENGTH (a smaller than selected) THAT ACTUALLY BRINGS EKIN EXACTLY TO THE THRESHOLD.
    //       SO THE TRACK LENGTH IS NOT PRECISE, SINCE WE KNOW THAT THE e- WAS STOPPED IN THIS VOLUME/BOX
    //       BUT WE DON'T COMPUTE THE EXCT POSITION
    if (eFinal < elData.fElectronCut) {
      // deposit the whole energy and stop tracking
      track.fEdep  = track.fEkin;
      track.fEkin  = 0.0;
      if (track.fType == +1) {
        // annihilate the e+ at the correct position !!!
        track.fPosition[0] += track.fDirection[0]*stepLength;
        track.fPosition[1] += track.fDirection[1]*stepLength;
        track.fPosition[2] += track.fDirection[2]*stepLength;
        // make sure that the mat index is up to date
        geom.DistanceToBoundary(track.fPosition, track.fDirection, track.fBoxIndx);
        theVoxelMatIndx = geom.GetMaterialIndex(track.fBoxIndx);
        track.fMatIndx  = theVoxelMatIndx;
        PerformAnnihilation(track);
      }
      whatHappend  = 4;
    } else {
      track.fEkin  = eFinal;
      track.fEdep  = deltE;
    }
    //
    // Update particle position, track length etc.
    track.fPosition[0] += track.fDirection[0]*stepLength;
    track.fPosition[1] += track.fDirection[1]*stepLength;
    track.fPosition[2] += track.fDirection[2]*stepLength;
    // update cummulative track length
    track.fStepLenght   = stepLength;
    track.fTrackLength += stepLength;
    //
    // Score the continuous energy loss before going back to perform the discrete
    // interaction (whatHappend={1,2,3}) OR to terminate the tracking (whatHappend=4)
    // NOTE: we need to score before calling DistanceToBoundary again because that
    //       might positon the particle to the next volume.

    geom.Score(track.fEdep, track.fBoxIndx[2]);
//    geom.Score(track.fEdep, track.fPosition[2]-track.fDirection[2]*stepLength);//-1.0E-4

//    if (std::abs(track.fPosition[0]) <= kHalfBoxSize && std::abs(track.fPosition[1]) <= kHalfBoxSize) {
//      geom.Score(track.fEdep, track.fBoxIndx[2]);
//    }

    //
    // Compute distance to boundary if geometry limited this step:
    // - if geometry limited the step, the current position above is on a
    //   volume/box boundary
    // - when calling DistanceToBoundary such that the position is within half
    //   tolerance to a boudnary, the track position is updated to be on the
    //   other side, the distance to boundary from the new positon is computed
    //   and the x,y and z box coordinate indices are updated (so the material
    //   index will be the new one)
    if (whatHappend==0) {
      stepGeom = geom.DistanceToBoundary(track.fPosition, track.fDirection, track.fBoxIndx);
      if (stepGeom<0.0) {
        // left the geometry
        track.fEkin = 0.0;
        return 4;
      }
    }
  }
  return whatHappend;
}


void KeepTrackingPhoton(PhotonData& phData, Geom& geom, Track& track) {
  const double kPI      = 3.1415926535897932;
  const double kEMC2    = 0.510991;
  const double kInvEMC2 = 1.0/kEMC2;
  //
  while (track.fEkin > 0.0) {
    // get the global max-macroscopic cross section and use it for samppling the
    // the length till the next photon intercation (that includes delta interaction
    // as well)
    double globalMaxMXsec = phData.GetGlobalMaxIMFP(track.fEkin);
    double     stepLength = -1.0*std::log(Random::UniformRand())/globalMaxMXsec;
    // Update particle position, track length etc.
    track.fPosition[0] += track.fDirection[0]*stepLength;
    track.fPosition[1] += track.fDirection[1]*stepLength;
    track.fPosition[2] += track.fDirection[2]*stepLength;

    // update cummulative track length
    track.fStepLenght   = stepLength;
    track.fTrackLength += stepLength;
    // determine currecnt voxel index
    if (geom.DistanceToBoundary(track.fPosition, track.fDirection, track.fBoxIndx) < 0) {
      // left the geometry
      track.fEkin = 0.0;
      return;
    }
    //
    // check if any interaction happened
    int theVoxelMatIndx = geom.GetMaterialIndex(track.fBoxIndx);
    if (theVoxelMatIndx < 0) {
      // terminate because its in the vacuum
      track.fEkin = 0.0;
      return;
    }
    track.fMatIndx      = theVoxelMatIndx;
    //
    double totalIMFP = phData.GetTotalIMFP(track.fEkin, theVoxelMatIndx);
    //
    // P(no-inetaction) = 1.0-mxsecTotal/mxsecGlobalMax
    const double r1 = Random::UniformRand();
    double theProb = 1.0-totalIMFP/globalMaxMXsec;
    if (r1 < theProb) {
      continue; // with the same globalMaxMXsec since the enrgy did not changed !!!
    }
    //
    // otherwise: check which interaction happend P(i) = mxsec-i/mxsecTotal
    // compute cumulated probability of adding Compton prob
    theProb += phData.GetComptonIMFP(track.fEkin, theVoxelMatIndx)/globalMaxMXsec;
    if (r1 < theProb) {
      // Compton interaction: Klein-Nishina like
      // the photon scattering angle and post-interafctin energy fraction
      double phCost  = -1.0;
      const double theEps = SampleETransferInKleinNishina(track.fEkin, phData, phCost);
      const double phEner = theEps*track.fEkin;
      const double phPhi  = 2.0*kPI*Random::UniformRand();
      const double elEner = track.fEkin-phEner;
      // insert the secondary e- only if ist energy is above the tracking cut
      // and deposit the corresponding enrgy otherwise
      if (elEner < phData.fElectronCut) {
        geom.Score(elEner, track.fBoxIndx[2]);
        //geom.Score(elEner, track.fPosition[2]);
      } else {
        // insert secondary e- but first compute its cost
        const double e0 = track.fEkin*kInvEMC2;
        double elCost   = (1.0+e0)*std::sqrt((1.0-theEps)/(e0*(2.0+e0*(1.0-theEps))));
        //
        Track& aTrack        = TrackStack::Instance().Insert();
        aTrack.fType         = -1;
        aTrack.fEkin         = elEner;
        aTrack.fMatIndx      = track.fMatIndx;
        aTrack.fPosition[0]  = track.fPosition[0];
        aTrack.fPosition[1]  = track.fPosition[1];
        aTrack.fPosition[2]  = track.fPosition[2];
        aTrack.fBoxIndx[0]   = track.fBoxIndx[0];
        aTrack.fBoxIndx[1]   = track.fBoxIndx[1];
        aTrack.fBoxIndx[2]   = track.fBoxIndx[2];
        const double sint    = std::sqrt((1.0+elCost)*(1.0-elCost));
        const double phi     = phPhi+kPI;
        aTrack.fDirection[0] = sint*std::cos(phi);
        aTrack.fDirection[1] = sint*std::sin(phi);
        aTrack.fDirection[2] = elCost;
        RotateToLabFrame(aTrack.fDirection, track.fDirection);
      }
      // update the photon properties:
      // stop the photon if its energy dropepd below the photon absorption threshold
      track.fEkin = phEner;
      if (track.fEkin < phData.fGammaCut) {
        geom.Score(track.fEkin, track.fBoxIndx[2]);
        //geom.Score(track.fEkin, track.fPosition[2]);
        track.fEkin = 0.0;
        return;
      } else {
        double phSint = std::sqrt((1.0-phCost)*(1.0+phCost));
        double u1 = phSint*std::cos(phPhi);
        double u2 = phSint*std::sin(phPhi);
        double u3 = phCost;
        // rotate new direction from the scattering to the lab frame
        RotateToLabFrame(u1, u2, u3, track.fDirection[0], track.fDirection[1], track.fDirection[2]);
        // update track direction
        track.fDirection[0] = u1;
        track.fDirection[1] = u2;
        track.fDirection[2] = u3;
      }
      continue;
    }

    // compute cumulated probability of adding Pair-production prob
    theProb += phData.GetPairIMFP(track.fEkin, theVoxelMatIndx)/globalMaxMXsec;
    if (r1 < theProb) {
      // Pair-production interaction:
      const double sumEkin = track.fEkin-2.0*kEMC2;
      // simple uniform share of the enrgy between the e- and e+ going to the
      // same direction as the original photon.
      // no difference between the e- and e+ transport till the end:
      // - when the e+ stops, 2 photons are emitted
      // we will assume that e1 is the e+
      double e1 = Random::UniformRand()*sumEkin;
      double e2 = sumEkin-e1;
      // insert the e- and e+ only if their energy is above the tracking cut
      // the e-
      if (e2<phData.fElectronCut) {
        geom.Score(e2, track.fBoxIndx[2]);
        //geom.Score(e2, track.fPosition[2]);
      } else {
        Track& aTrack        = TrackStack::Instance().Insert();
        aTrack.fType         = -1;
        aTrack.fEkin         = e2;
        aTrack.fMatIndx      = track.fMatIndx;
        aTrack.fPosition[0]  = track.fPosition[0];
        aTrack.fPosition[1]  = track.fPosition[1];
        aTrack.fPosition[2]  = track.fPosition[2];
        aTrack.fBoxIndx[0]   = track.fBoxIndx[0];
        aTrack.fBoxIndx[1]   = track.fBoxIndx[1];
        aTrack.fBoxIndx[2]   = track.fBoxIndx[2];
        aTrack.fDirection[0] = track.fDirection[0];
        aTrack.fDirection[1] = track.fDirection[1];
        aTrack.fDirection[2] = track.fDirection[2];
      }
      // the e+
      if (e1<phData.fElectronCut) {
        geom.Score(e1, track.fBoxIndx[2]);
        //geom.Score(e1, track.fPosition[2]);
        PerformAnnihilation(track);
      } else {
        Track& aTrack        = TrackStack::Instance().Insert();
        aTrack.fType         = +1;
        aTrack.fEkin         = e1;
        aTrack.fMatIndx      = track.fMatIndx;
        aTrack.fPosition[0]  = track.fPosition[0];
        aTrack.fPosition[1]  = track.fPosition[1];
        aTrack.fPosition[2]  = track.fPosition[2];
        aTrack.fBoxIndx[0]   = track.fBoxIndx[0];
        aTrack.fBoxIndx[1]   = track.fBoxIndx[1];
        aTrack.fBoxIndx[2]   = track.fBoxIndx[2];
        aTrack.fDirection[0] = track.fDirection[0];
        aTrack.fDirection[1] = track.fDirection[1];
        aTrack.fDirection[2] = track.fDirection[2];
      }
      // kill the primary photon
      track.fEkin = 0.0;
      return;
    }

    // if we are here then Photoelectric effect happens that absorbs the photon:
    // - score the current phton energy and stopp the photon
    geom.Score(track.fEkin, track.fBoxIndx[2]);
    //geom.Score(track.fEkin, track.fPosition[2]);
    track.fEkin = 0.0;
  };
}



// ekin - pre-interaction e- kinetic energy (E0)
// cut  - secondary e- production threshold energy (cut)
// returns the energy and cost of the secondary OR zero if no interaction possible
double SampleETransferInMoller(double ekin, double ecut, ElectronData& elData, double& cost) {
  const double kEMC2    = 0.510991;
  const double kInvEMC2 = 1.0/kEMC2;
  const double k2EMC2   = 2.0*kEMC2;
  // energy transfer is sampled in E0 units and E0 must be at least 2cut
  const double kcut     = ecut/ekin;
  if (kcut<0.5) {
    //
    // Sampling without rejection
    const double secEkin = elData.fMollerTables->SampleEnergyTransfer(ekin, ecut, Random::UniformRand(), Random::UniformRand(), Random::UniformRand());
    // --------------------------

    // Sampling with rejection
    /*
    const double dum0 = (1.0-1.0/(1.+ekin*kInvEMC2));
    const double dum1 = dum0*dum0;
    double res  = 0.0;
    double func = 0.0;
    do {
      if (Random::UniformRand()*(1.0+2.5*dum1*kcut)<1.0) {
        res = kcut/(1.0-Random::UniformRand()*(1.0-2.0*kcut));
      } else {
        res = kcut+Random::UniformRand()*(0.5-kcut);
      }
      const double dum2 = res/(1.0-res);
      const double dum3 = dum1*res*res;
      func = (1.0+dum3+dum2*(dum2+dum1-1.0))/(1.0+5.0*dum3);
    } while (Random::UniformRand()>func);
    // res contains now the fractional energy loss dE/E0 so compute dE and cost
    const double secEkin = res*ekin;
    // --------------------------
    */


    cost = std::min(1.0, std::sqrt(secEkin*(ekin+k2EMC2)/(ekin*(secEkin+k2EMC2))));
    return secEkin;
  } else {
    // no interaction is possible if E0 < 2cut: both the final primary and secondary
    // kinetic energies must be > cut because they are indistinguishable
    return 0.0;
  }
}

// returns with the post interaction gamma energy fraction (i.e. E_photon'=frac*E_photon)
// and cost of its scatteing
double SampleETransferInKleinNishina(double egamma, PhotonData& phData, double& cost) {
  const double kEMC2    = 0.510991;
  const double kInvEMC2 = 1.0/kEMC2;
  //
  // Sampling without rejection
  double eps   = phData.fKNTables->SampleEnergyTransfer(egamma, Random::UniformRand(), Random::UniformRand(), Random::UniformRand());
  double kappa = egamma/kEMC2;
  cost = 1.-(1.-eps)/(eps*kappa); // 1- (1-cost)
  return eps;
  // --------------------------

  // Sampling with rejection
  /*
  double e0     = egamma*kInvEMC2;
  double eps0   = 1.0/(1.0 + 2.0*e0);
  double eps02  = eps0*eps0;
  double alpha1 = -std::log(eps0);
  double alpha2 = alpha1 + 0.5*(1.0- eps02);
  double eps, eps2, onecost, sint2, reject;
  do {
    if ( alpha1 > alpha2*Random::UniformRand() ) {
      eps  = std::exp(-alpha1*Random::UniformRand());
      eps2 = eps*eps;
    } else {
      eps2 = eps02 + (1.0- eps02)*Random::UniformRand();
      eps  = sqrt(eps2);
    }
    onecost = (1.0 - eps)/(eps*e0);
    sint2   = onecost*(2.0-onecost);
    reject  = 1.0 - eps*sint2/(1.0+ eps2);
  } while (reject < Random::UniformRand());
  //
  cost = 1.0-onecost;
  return eps;
  // --------------------------
  */
}


void PerformAnnihilation(Track& track) {
  const double kPI      = 3.1415926535897932;
  const double kEMC2    = 0.510991;
  // isotropic direction
  const double cost = 1.0-2.0*Random::UniformRand();
  const double sint = std::sqrt((1.0-cost)*(1.0+cost));
  const double phi  = 2.0*kPI*Random::UniformRand();
  const double rx   = sint*cos(phi);
  const double ry   = sint*sin(phi);
  const double rz   = cost;

  Track& aTrack        = TrackStack::Instance().Insert();
  aTrack.fType         = 0;
  aTrack.fEkin         = kEMC2;
  aTrack.fMatIndx      = track.fMatIndx;
  aTrack.fPosition[0]  = track.fPosition[0];
  aTrack.fPosition[1]  = track.fPosition[1];
  aTrack.fPosition[2]  = track.fPosition[2];
  aTrack.fBoxIndx[0]   = track.fBoxIndx[0];
  aTrack.fBoxIndx[1]   = track.fBoxIndx[1];
  aTrack.fBoxIndx[2]   = track.fBoxIndx[2];
  aTrack.fDirection[0] = rx;
  aTrack.fDirection[1] = ry;
  aTrack.fDirection[2] = rz;

  Track& aTrack1        = TrackStack::Instance().Insert();
  aTrack1.fType         = 0;
  aTrack1.fEkin         = kEMC2;
  aTrack1.fMatIndx      = track.fMatIndx;
  aTrack1.fPosition[0]  = track.fPosition[0];
  aTrack1.fPosition[1]  = track.fPosition[1];
  aTrack1.fPosition[2]  = track.fPosition[2];
  aTrack1.fBoxIndx[0]   = track.fBoxIndx[0];
  aTrack1.fBoxIndx[1]   = track.fBoxIndx[1];
  aTrack1.fBoxIndx[2]   = track.fBoxIndx[2];
  aTrack1.fDirection[0] = -rx;
  aTrack1.fDirection[1] = -ry;
  aTrack1.fDirection[2] = -rz;
}


#endif // Simulate_HH
